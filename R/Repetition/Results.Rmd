---
title: "Replication Analysis"
author: "Clémentine de Montgolfier"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
output: html_document
---

```{r options, include=FALSE}
# set working dir for all chunks to ..
knitr::opts_knit$set(root.dir = "../../")
```

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(fs)
library(gridExtra)
library(grid)
library(knitr)
library(patchwork)
load("R/Repetition/data/mean.RData") # all_data
```

# Testing number of repetitions necessary for convergence of the variation coefficient

```{r, message=FALSE, warning=FALSE}
m_analyse <- function(all_data, nb_simul = 10, variable = TotalBasalArea.m2.ha) {
  library(dplyr)
  library(ggplot2)
  
  # Create empty data frame to store final results
  df <- data.frame()
  
  # List of all available simulation IDs
  simulation <- 1:5000
  
  # Perform 387 repetitions of random sampling
  for (rep in 1:round(5000 / nb_simul, 0)) {
    
    # Initialize a temporary data frame to hold results for this repetition
    oneRep <- data.frame()
    
    # Randomly sample 'nb_simul' unique simulation IDs without replacement
    l <- sample(simulation, nb_simul, replace = FALSE)
    
    # Filter 'all_data' to include only rows with the sampled simulations
    oneRep <- all_data[all_data$simulation %in% l, ] %>%
      mutate(n = nb_simul) %>%
      bind_rows(oneRep)
    
    # Remove used simulation IDs from the pool
    simulation <- simulation[!simulation %in% l]
    
    # Add repetition number and bind to the global results data frame
    df <- oneRep %>%
      mutate(rep = rep) %>%
      bind_rows(df)
  }
  
  # Group repetitions into different sizes (e.g., 2, 5, 10, ..., 200)
  df <- df %>%
    mutate(m = case_when(
      rep <= 5 ~ 5,
      rep <= 15 ~ 10,
      rep <= 65 ~ 50,
      rep <= 165 ~ 100,
      rep <= 315 ~ 150,
      rep <= 515 ~ 200,
      rep <= 765 ~ 250,
      rep <= 1065 ~ 300,
      rep <= 1415 ~ 350,
      rep <= 1815 ~ 400,
      TRUE ~ NA
    )) %>%
    filter(!is.na(m), rep < round(5000 / nb_simul, 0))  # Remove rows with undefined group size
  
  # Compute mean of selected variable for each (rep, m, n, date)
  df_mean <- df %>%
    group_by(rep, m, n, date) %>%
    summarise(mean_val = mean({{ variable }}, na.rm = TRUE), .groups = 'drop')
  
  # Plot the mean trajectories
  p1 <- df_mean %>%
    ggplot(aes(x = date, y = mean_val, color = factor(rep))) +
    geom_line() +
    facet_wrap(~m) +
    theme_minimal() +
    theme(legend.position = "none") +
    labs(
      title = "Mean Value by Repetition",
      x = "Date",
      y = deparse(substitute(variable)),
      color = "Rep"
    )
  
  # Calculate coefficient of variation (CV) and error
  df_cv <- df_mean %>%
    group_by(m, date) %>%
    summarise(
      cv = sd(mean_val, na.rm = TRUE) / mean(mean_val, na.rm = TRUE),
      erreur = 1.833 * sd(mean_val, na.rm = TRUE) / sqrt(nb_simul),
      .groups = 'drop'
    ) %>%
    group_by(m) %>%
    summarise(cv = max(cv), erreur = max(erreur), .groups = 'drop')
  
  p2 <- df_cv %>%
    ggplot(aes(x = m, y = cv)) +
    geom_line() +
    theme_minimal() +
    labs(
      title = "Coefficient of Variation by Number of Repetitions",
      x = "Number of Repetitions (m)",
      y = "Coefficient of Variation (CV)"
    )
  
  return(list(
    plot_mean = p1,
    cv_table = df_cv,
    plot_cv = p2
  ))
}

```

## Total Basal Area

### For 2 simulations

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 1 : Coefficient de variation pour 2 simulations (#fig:cv2)"}
# Run the simulation for 2 repetitions
results <- m_analyse(all_data, nb_simul = 2, variable = totalBasalArea.m2.ha)

# Convertir la table en 'tableGrob'
table_grob <- tableGrob(
  results$cv_table,
  rows = NULL,  # <- Supprime les numéros de lignes
  theme = ttheme_default(
    core = list(fg_params = list(cex = 1.2)),     # taille du texte dans les cellules
    colhead = list(fg_params = list(cex = 1.2))   # taille du texte dans l'en-tête
  )
)

# Afficher côte à côte
grid.arrange(results$plot_cv + ylim(0,0.2), table_grob, ncol = 2)
```

Pour 2 simulations il est autour de 0.1 mais plus stable après m = 50
Ecart type de 4

### For 10 simulations

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 2 : Coefficient de variation pour 10 simulations (#fig:cv10)"}
# Run the simulation for 10 repetitions
results <- m_analyse(all_data, nb_simul = 10, variable = totalBasalArea.m2.ha)

# Convertir la table en 'tableGrob'
table_grob <- tableGrob(
  results$cv_table,
  rows = NULL,  # <- Supprime les numéros de lignes
  theme = ttheme_default(
    core = list(fg_params = list(cex = 1.2)),     # taille du texte dans les cellules
    colhead = list(fg_params = list(cex = 1.2))   # taille du texte dans l'en-tête
  )
)

# Afficher côte à côte
grid.arrange(results$plot_cv + ylim(0,0.2), table_grob, ncol = 2)
```

Le coefficient de variation est relativement stable (autour de 0.05) pour 10 simulation dès m = 5
Ecart type de +/- 1, 

### For 50 simulations

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 3 : Coefficient de variation pour 50 simulations (#fig:cv50)"}
# Run the simulation for 50 repetitions
results <- m_analyse(all_data, nb_simul = 50, variable = totalBasalArea.m2.ha)

# Convertir la table en 'tableGrob'
table_grob <- tableGrob(
  results$cv_table,
  rows = NULL,  # <- Supprime les numéros de lignes
  theme = ttheme_default(
    core = list(fg_params = list(cex = 1.2)),     # taille du texte dans les cellules
    colhead = list(fg_params = list(cex = 1.2))   # taille du texte dans l'en-tête
  )
)

# Afficher côte à côte
grid.arrange(results$plot_cv + ylim(0,0.2), table_grob, ncol = 2)
```

Très très stable, d-s 10.
Ecart type de 0.2 (ce qui est très peu pour une surface terrière)

## Total Volume

### For 2 simulations

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 4 : CV pour 2 simulations (Volume) (#fig:cv2vol)"}
# Run the simulation for 2 repetitions
results <- m_analyse(all_data, nb_simul = 2, variable = totalVolume.m3.ha)
# Convertir la table en 'tableGrob'
table_grob <- tableGrob(
  results$cv_table,
  rows = NULL,  # <- Supprime les numéros de lignes
  theme = ttheme_default(
    core = list(fg_params = list(cex = 1.2)),     # taille du texte dans les cellules
    colhead = list(fg_params = list(cex = 1.2))   # taille du texte dans l'en-tête
  )
)
# Afficher côte à côte
grid.arrange(results$plot_cv + ylim(0,0.2), table_grob, ncol = 2)
```

### For 10 simulations

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 5 : CV pour 10 simulations (Volume) (#fig:cv10vol)"}
# Run the simulation for 10 repetitions
results <- m_analyse(all_data, nb_simul = 10, variable = totalVolume.m3.ha)
# Convertir la table en 'tableGrob'
table_grob <- tableGrob(
  results$cv_table,
  rows = NULL,  # <- Supprime les numéros de lignes
  theme = ttheme_default(
    core = list(fg_params = list(cex = 1.2)),     # taille du texte dans les cellules
    colhead = list(fg_params = list(cex = 1.2))   # taille du texte dans l'en-tête
  )
)
# Afficher côte à côte
grid.arrange(results$plot_cv + ylim(0,0.2), table_grob, ncol = 2)
```

## Total Biomass

### For 2 simulations

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 6 : CV pour 2 simulations (Biomasse) (#fig:cv2bio)"}
# Run the simulation for 2 repetitions
results <- m_analyse(all_data, nb_simul = 2, variable = totalBiomass.t.ha)
# Convertir la table en 'tableGrob'
table_grob <- tableGrob(
  results$cv_table,
  rows = NULL,  # <- Supprime les numéros de lignes
  theme = ttheme_default(
    core = list(fg_params = list(cex = 1.2)),     # taille du texte dans les cellules
    colhead = list(fg_params = list(cex = 1.2))   # taille du texte dans l'en-tête
  )
)
# Afficher côte à côte
grid.arrange(results$plot_cv + ylim(0,0.2), table_grob, ncol = 2)
```

### For 10 simulations
```{r, message=FALSE, warning=FALSE, fig.cap="Figure 7 : CV pour 10 simulations (Biomasse) (#fig:cv10bio)"}
# Run the simulation for 10 repetitions
results <- m_analyse(all_data, nb_simul = 10, variable = totalBiomass.t.ha)
# Convertir la table en 'tableGrob'
table_grob <- tableGrob(
  results$cv_table,
  rows = NULL,  # <- Supprime les numéros de lignes
  theme = ttheme_default(
    core = list(fg_params = list(cex = 1.2)),     # taille du texte dans les cellules
    colhead = list(fg_params = list(cex = 1.2))   # taille du texte dans l'en-tête
  )
)
# Afficher côte à côte
grid.arrange(results$plot_cv + ylim(0,0.2), table_grob, ncol = 2)
```

# Variation du coefficient de variation avec le nombre de simulations

```{r, message=FALSE, warning=FALSE}
n_analyses <- function(all_data, variable = TotalBasalArea.m2.ha, groupes = c(1, 5, 10, 20, 30, 50, 75, 100, 150), nb_rep = 10) {
  library(dplyr)
  library(ggplot2)
  
  df <- data.frame()
  simulation <- 1:5000
  
  # Boucle sur les répétitions
  for (m in 1:nb_rep) {
    oneRep <- data.frame()
    for (i in seq_along(groupes)) {
      l <- sample(simulation, groupes[i], replace = FALSE)
      oneRep <- all_data[all_data$simulation %in% l, ] %>%
        mutate(n = groupes[i]) %>%
        bind_rows(oneRep)
      simulation <- setdiff(simulation, l)
    }
    df <- oneRep %>%
      mutate(m = m) %>%
      bind_rows(df)
  }
  
  # Calcul des moyennes par (m, n, date)
  df_mean <- df %>%
    group_by(m, n, date) %>%
    summarise(mean_val = mean({{ variable }}, na.rm = TRUE), .groups = "drop")
  
  # Tracé des trajectoires de moyenne
  plot_mean <- df_mean %>%
    ggplot(aes(x = date, y = mean_val, color = factor(m))) +
    geom_line() +
    facet_wrap(~n) +
    theme_minimal() +
    theme(legend.position = "none") +
    #ylim(0, 40) +
    labs(
      title = "Mean trajectories",
      x = "Date",
      y = deparse(substitute(variable)),
      color = "Rep"
    )
  
  # Calcul du coefficient de variation et de l'erreur
  df_cv <- df_mean %>%
    group_by(n, date) %>%
    summarise(
      cv = sd(mean_val, na.rm = TRUE) / mean(mean_val, na.rm = TRUE),
      error = 1.833 * sd(mean_val, na.rm = TRUE) / sqrt(n()),
      .groups = 'drop'
    ) %>%
    group_by(n) %>%
    summarise(
      cv = max(cv),
      error = max(error),
      .groups = 'drop'
    )
  
  # Graphiques CV et Erreur
  plot_cv <- df_cv %>%
    ggplot(aes(x = n, y = cv)) +
    geom_line() +
    theme_minimal() +
    ylim(0, 0.2) +
    labs(
      title = "Coefficient of Variation (CV)",
      x = "Number of simulations",
      y = "CV"
    )
  
  plot_error <- df_cv %>%
    ggplot(aes(x = n, y = error)) +
    geom_line() +
    theme_minimal() +
    labs(
      title = "Standardized Error",
      x = "Number of simulations",
      y = "Error"
    )
  
  return(list(
    plot_mean = plot_mean,
    plot_cv = plot_cv,
    plot_error = plot_error,
    summary_table = df_cv
  ))
}
```	

## Total Basal Area

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 8 : Analyse du nombre de simulations pour la surface terrière (#fig:nanalysesba)"}
# Exécuter l'analyse pour le totalBasalArea.m2.ha
results <- n_analyses(all_data, variable = totalBasalArea.m2.ha)
# Afficher les graphiques côte à côte
grid.arrange(results$plot_mean, results$plot_cv, results$plot_error, ncol = 3)
```

## Total Volume

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 9 : Analyse du nombre de simulations pour le volume (#fig:nanalysesvol)"}
# Exécuter l'analyse pour le totalVolume.m3.ha
results <- n_analyses(all_data, variable = totalVolume.m3.ha)
# Afficher les graphiques côte à côte
grid.arrange(results$plot_mean, results$plot_cv, results$plot_error, ncol = 3)
```

## Total Biomass

```{r, message=FALSE, warning=FALSE, fig.cap="Figure 10 : Analyse du nombre de simulations pour la biomasse (#fig:nanalysesbio)"}
# Exécuter l'analyse pour le totalBiomass.t.ha
results <- n_analyses(all_data, variable = totalBiomass.t.ha)
# Afficher les graphiques côte à côte
grid.arrange(results$plot_mean, results$plot_cv, results$plot_error, ncol = 3)
```

Il me faudrait plus de répétition pour voir la convergence mais l'erreur standardisée est faible pour 100 simulations

# Pareil pour la Production (par espèce dans le tableau .productivityScene)

## Par espèce

```{r}
load("R/Repetition/data/productivityScene.RData") # global_df
```

```{r, message=FALSE, warning=FALSE, fig.width=12, fig.height=16, fig.cap="Figure 11 : Analyse de la production par espèce (#fig:prod)"}
global_df_sp <- global_df %>%
  filter(speciesShortName != "Tot")

# Tracé des trajectoires de moyenne
plot_mean <- global_df_sp %>%
  group_by(date, speciesShortName,n, m) %>%
  summarise(mean_val = mean(mean_val))%>%
  ggplot(aes(x = date, y = mean_val, color = factor(m))) +
  geom_line() +
  # facet grid on speciesShortName and n
  facet_grid(speciesShortName ~ n) +
  theme_minimal() +
  theme(legend.position = "none") +
  #ylim(0, 40) +
  labs(
    title = "Mean trajectories",
    x = "Date",
    y = "adultProdBasalArea (m2/ha)",
    color = "Rep"
)

# Calcul du coefficient de variation et de l'erreur
df_cv <- global_df_sp %>%
  group_by(n, date, speciesShortName) %>%
  summarise(
    sd = sd(mean_val, na.rm = TRUE),
    cv = sd(mean_val, na.rm = TRUE) / mean(mean_val, na.rm = TRUE),
    error = 1.833 * sd(mean_val, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  ) %>%
  group_by(n) %>%
  summarise(
    sd = max(sd, na.rm = TRUE),
    cv = max(cv, na.rm = TRUE),
    error = max(error),
    .groups = 'drop'
  )

  # Graphiques CV et Erreur
plot_cv <- df_cv %>%
  ggplot(aes(x = n, y = cv)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Coefficient of Variation (CV)",
    x = "Number of simulations",
    y = "CV"
  )
plot_sd <- df_cv %>%
  ggplot(aes(x = n, y = sd)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Standard Deviation",
    x = "Number of simulations",
    y = "Standard Deviation"
  )
  
plot_error <- df_cv %>%
  ggplot(aes(x = n, y = error)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Standardized Error",
    x = "Number of simulations",
    y = "Error"
  )

plot_mean / (plot_cv + plot_error) +
  plot_layout(ncol = 1) +
  plot_annotation(title = "Production Analysis", theme = theme(plot.title = element_text(hjust = 0.5)))
```

## Total sur toutes les espèces

```{r, message=FALSE, warning=FALSE, fig.width=12, fig.height=8, fig.cap="Figure 12 : Analyse de la production totale (#fig:prodtotal)"}
global_df_tot <- global_df %>%
  filter(speciesShortName == "Tot")

# seuil à 10% de la valeur
seuil5 <- 0.05 * mean(global_df_tot$mean_val, na.rm = TRUE)
seuil10 <- 0.1 * mean(global_df_tot$mean_val, na.rm = TRUE)

# Tracé des trajectoires de moyenne
plot_mean_tot <- global_df_tot %>%
  group_by(date, n, m) %>%
  summarise(mean_val = mean(mean_val)) %>%
  ggplot(aes(x = date, y = mean_val, color = factor(m))) +
  geom_line() +
  facet_wrap(~n) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(
    title = "Mean trajectories (Total)",
    x = "Date",
    y = "adultProdBasalArea (m2/ha)",
    color = "Rep"
  )

# Calcul du coefficient de variation et de l'erreur
df_cv_tot <- global_df_tot %>%
  group_by(n, date) %>%
  summarise(
    sd = sd(mean_val, na.rm = TRUE),
    cv = sd(mean_val, na.rm = TRUE) / mean(mean_val, na.rm = TRUE),
    error = 1.833 * sd(mean_val, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  ) %>%
  group_by(n) %>%
  summarise(
    sd = max(sd, na.rm = TRUE),
    cv = max(cv, na.rm = TRUE),
    error = max(error),
    .groups = 'drop'
  )

# Graphiques CV et Erreur
plot_cv_tot <- df_cv_tot %>%
  ggplot(aes(x = n, y = cv)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Coefficient of Variation (CV) (Total)",
    x = "Number of simulations",
    y = "CV"
  )

plot_sd_tot <- df_cv_tot %>%
  ggplot(aes(x = n, y = sd)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Standard Deviation (Total)",
    x = "Number of simulations",
    y = "Standard Deviation"
  )

plot_error_tot <- df_cv_tot %>%
  ggplot(aes(x = n, y = error)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Standardized Error (Total)",
    x = "Number of simulations",
    y = "Error"
  ) +
  geom_hline(yintercept = seuil5, linetype = "dashed", color = "red") +
  geom_hline(yintercept = seuil10, linetype = "dashed", color = "blue") +
  annotate("text", x = max(df_cv_tot$n), y = seuil5, label = "5%", color = "red", vjust = -1) +
  annotate("text", x = max(df_cv_tot$n), y = seuil10, label = "10%", color = "blue", vjust = -1)

# valeur de l'intersection entre la courbe de moyenne et le seuil
intersect_value <- df_cv_tot %>%
  filter(error < 5) %>%
  summarise(n = min(n, na.rm = TRUE)) %>%
  pull(n)

plot_mean_tot / (plot_cv_tot + plot_error_tot) +
  plot_layout(ncol = 1) +
  plot_annotation(title = "Total Production Analysis", theme = theme(plot.title = element_text(hjust = 0.5)))
```

seuil  par rapport à la moyenne de la production totale :
Pour 5% de seuil il faut 50 répétitions  
Pour 10% d'erreur il faut 10 répétitions

# Arbre morts

deadNumber_ha dans productivity scene

```{r, message=FALSE, warning=FALSE, fig.width=12, fig.height=8, fig.cap="Figure 13 : Analyse du nombre d'arbres mort (#fig:deadtotal)"}
global_df_tot <- global_df %>%
  filter(speciesShortName == "Tot")

# seuil à 10% de la valeur
seuil10 <- 0.1 * mean(global_df_tot$dead_total, na.rm = TRUE)
seuil5 <- 0.05 * mean(global_df_tot$dead_total, na.rm = TRUE)

# Tracé des trajectoires de moyenne
plot_mean_tot <- global_df_tot %>%
  group_by(date, n, m) %>%
  summarise(dead_total = mean(dead_total)) %>%
  ggplot(aes(x = date, y = dead_total, color = factor(m))) +
  geom_line() +
  facet_wrap(~n) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(
    title = "Mean trajectories (Total)",
    x = "Date",
    y = "adultProdBasalArea (m2/ha)",
    color = "Rep"
  )

# Calcul du coefficient de variation et de l'erreur
df_cv_tot <- global_df_tot %>%
  group_by(n, date) %>%
  summarise(
    sd = sd(dead_total, na.rm = TRUE),
    cv = sd(dead_total, na.rm = TRUE) / mean(dead_total, na.rm = TRUE),
    error = 1.833 * sd(dead_total, na.rm = TRUE) / sqrt(n()),
    .groups = 'drop'
  ) %>%
  group_by(n) %>%
  summarise(
    sd = max(sd, na.rm = TRUE),
    cv = max(cv, na.rm = TRUE),
    error = max(error),
    .groups = 'drop'
  )

# Graphiques CV et Erreur
plot_cv_tot <- df_cv_tot %>%
  ggplot(aes(x = n, y = cv)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Coefficient of Variation (CV) (Total)",
    x = "Number of simulations",
    y = "CV"
  )

plot_sd_tot <- df_cv_tot %>%
  ggplot(aes(x = n, y = sd)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Standard Deviation (Total)",
    x = "Number of simulations",
    y = "Standard Deviation"
  )

plot_error_tot <- df_cv_tot %>%
  ggplot(aes(x = n, y = error)) +
  geom_line() +
  theme_minimal() +
  labs(
    title = "Standardized Error (Total)",
    x = "Number of simulations",
    y = "Error"
  ) +
  geom_hline(yintercept = seuil5, linetype = "dashed", color = "red") +
  geom_hline(yintercept = seuil10, linetype = "dashed", color = "blue") +
  annotate("text", x = max(df_cv_tot$n), y = seuil5, label = "5%", color = "red", vjust = -1) +
  annotate("text", x = max(df_cv_tot$n), y = seuil10, label = "10%", color = "blue", vjust = -1)

# valeur de l'intersection entre la courbe de moyenne et le seuil
intersect_value <- df_cv_tot %>%
  filter(error < seuil5) %>%
  summarise(n = min(n, na.rm = TRUE)) %>%
  pull(n)

plot_mean_tot / (plot_cv_tot + plot_error_tot) +
  plot_layout(ncol = 1) +
  plot_annotation(title = "Total Production Analysis", theme = theme(plot.title = element_text(hjust = 0.5)))
```

20 pour 10%  
et 50 pour 5%

# Précision gagnée en augmentant le nombre de répétition

Faire le même travail mais avec une seule courbe et les groupes de 1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 500

```{r, message=FALSE, warning=FALSE}
# Create groups of repetitions
groupes = c(1, 5, 10, 20, 30, 50, 75, 100, 150)

df <- data.frame()
simulation = 1:5000
for(rep in 1:10){
    oneRep = data.frame()
    for(i in 1:length(groupes)){
        l = sample(simulation, groupes[i], replace = FALSE)
        oneRep <- all_data[all_data$simulation %in% l,] %>%
            mutate(n = groupes[i]) %>%
            bind_rows(oneRep)
        simulation = simulation[!simulation %in% l]
    }
    df <- oneRep %>%
        mutate(rep = rep) %>%
        bind_rows(df)
}
```

```{r, message=FALSE, warning=FALSE}
# create the mean
df_mean <- df %>%
    group_by(rep, n, date) %>%
    summarise(across(totalBasalArea.m2.ha, mean, na.rm = TRUE)) %>%
    ungroup()

# create the epsilon
df_epsilon <- df_mean %>%
    group_by(rep, n) %>%
    summarise(
        epsilon = sum(abs(totalBasalArea.m2.ha - lag(totalBasalArea.m2.ha))/82, na.rm = TRUE),
        , na.rm = TRUE) %>%
    ungroup()

# create the plot
ggplot(df_epsilon) + # %>% filter(n> 1)) +
    geom_line(aes(x = n, y = epsilon, color = factor(rep))) +
    theme_minimal() +
    labs(title = "Forceps epsilon", x = "Nb simulation", y = "Value") +
    # ajouter en noir et gras la courbe moyenne
    geom_line(data = df_epsilon %>% group_by(n) %>% summarise(epsilon = mean(epsilon)), aes(x = n, y = epsilon), color = "black", size = 1.5) +
    # une ligne horizontale à 0.2
    geom_hline(yintercept = 0.2, linetype = "dashed", color = "red")
```

```{r, message=FALSE, warning=FALSE}
# create the mean
df_mean <- df %>%
    group_by(rep, n, date) %>%
    summarise(across(totalBasalArea.m2.ha, mean, na.rm = TRUE)) %>%
    ungroup()

# create the epsilon
df_epsilon <- df_mean %>%
    group_by(n, date) %>%
    summarise(
        epsilon = sd(totalBasalArea.m2.ha)/mean(totalBasalArea.m2.ha)) %>%
    ungroup() %>%
    group_by(n) %>%
    summarise(
        epsilon = mean(epsilon))

# create the plot
ggplot(df_epsilon) + # %>% filter(n> 1)) +
    geom_line(aes(x = n, y = epsilon, color = factor(rep))) +
    theme_minimal() +
    labs(title = "Forceps epsilon", x = "Nb simulation", y = "Value") +
    # ajouter en noir et gras la courbe moyenne
    geom_line(data = df_epsilon %>% group_by(n) %>% summarise(epsilon = mean(epsilon)), aes(x = n, y = epsilon), color = "black", size = 1.5)
```