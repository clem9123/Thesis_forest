---
title: "Multi-scale Analysis of Forest Management Scenarios: Testing Indicators Forest Management Scenarios Overview"
author: "Clementine de Montgolfier"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
output: html_document
---

# Note on simulation protocol and convention chosen

I created 1 command file for each patche
Inside I have one line for each itinerary

With Brieux naming convention : each line get a unique identifier simply simulation_# from 1 to number of itineraries ran.

To add repetitions (see forceeps_replicates analyses) there are multiple possibilities :  
- use different seed in the command file and then regroup simulations together. For example simulation 1-10 for the first itinerary, 11-20 for the second... (either by keeping very good track of what is done (and a lot of loops when importing data) or by having a table that gives the correspondances between simulation number and caracteristics of the simulation.)  
- change naming convention in forceeps (by modifying brieux scripts to get our own)

- [ ] Implement a system to repeat simulations

```{r options}
# Set working directory for all chunks to parent directory
knitr::opts_knit$set(root.dir = "../../")
# Set global chunk options
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.width = 8,
  fig.height = 8,
  fig.align = "center"
)
```

```{r libraries-and-data, message=FALSE, warning=FALSE}
library(tidyverse)
library(fs)
library(gridExtra)
library(grid)
library(knitr)
library(patchwork)
library(sf)
source("R/utils/output_utils.R")
```

```{r, message = FALSE, warning = FALSE, echo = FALSE}
productivity_scene <- import_output_scene(
  output_name = "productivityScene",
  base_path = "C:/Capsis4/data/forceps/clementine/Study_protocol/",
  output_file = "data/forceeps_output/protocole_productivityScene.RData"
)

mean_scene <- import_output_scene(
  output_name = "mean",
  base_path = "C:/Capsis4/data/forceps/clementine/Study_protocol/",
  output_file = "data/forceeps_output/protocole_meanScene.RData"
)
```

# Initial Stand Conditions

```{r}
# Retrieve plot IDs
plots_id <- productivity_scene %>%
  pull(plot_id) %>%
  unique()

# Select plot IDs from forest data
load("data/forest_data.RData")
forest_data %>% as.data.frame() %>% 
  filter(Identifiant.peuplement.élémentaire %in% plots_id) %>%
  select(Identifiant.peuplement.élémentaire, surface.retenue, Type.de.peuplement, Essence.déterminant.la.sylviculture, Essence.dominante.1, Essence.dominante.2, Structure.et.occupation.du.sol, surf.terrière.moy, diamètre.mean, median_age) %>%
  # Display as formatted table
  knitr::kable(
    caption = "Initial stand conditions for selected plots",
    col.names = c("Plot ID", "Surface (ha)", "Stand Type", "Silviculture Species", "Dominant Species 1", "Dominant Species 2", "Structure & Soil Cover", "Basal Area (m²/ha)", "Mean DBH (cm)", "Median Age (years)")
  )
```

```{r}
productivity_scene %>%
  filter(date == "2021") %>%
  group_by(plot_id, speciesShortName) %>%
  summarise(adultTreeBasalArea = sum(adultTreeBasalArea, na.rm = TRUE)) %>%
  ggplot(aes(x = plot_id, y = adultTreeBasalArea, fill = speciesShortName)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(
    title = "Initial Basal Area by Plot and Species (2021)",
    x = "Plot ID",
    y = "Basal Area (m²/ha)",
    fill = "Species"
  ) +
  theme_minimal()
```

The table below summarizes the diversity of the selected plots in terms of stand type and dominant species. This highlights the current selection's limited heterogeneity, suggesting the need to include a broader range of patches and avoid relying solely on random selection to ensure a more representative sample. (See l.32 in `Generate.R`)

- [ ] Change `Generate.R` to include more diverse plot selection criteria.

Also in subsequent analyses I considered each plot as equal but for applicable results :

- [ ] Need to add a weight to account for plot size

# Itinerary exploration

The study evaluates three distinct silvicultural strategies:

- **Clear-cut management** *(simulation1)*
  - Management cutting every 10 years removing 30% of volume (cutting type 0.5)
  - While maintaining initial species composition
  - Final clear-cut at maturity age of the dominant species

- **Continuous cover forestry** *(simulation2)*
  - Partial cutting every 5 years removing 10% of volume (cutting type 0.5)
  - Targeting equal (25%) composition of the four (or less if not found) main species

- **Natural evolution** *(simulation3)*
  - No management intervention
  - Natural forest dynamics without human interference

```{r}
ggplot(productivity_scene) +
  geom_line(aes(x = date, y = adultTreeBasalArea, color = speciesShortName)) +
  facet_grid(plot_id ~ scenario) +
  labs(
    title = "Forest Productivity by Plot and Species",
    x = "Year",
    y = "Basal Area (m²/ha)",
    color = "Species"
  ) +
  theme_minimal()
```

*Note: The decline in basal area observed in simulation 3 (natural evolution) likely results from natural mortality, as the management strategy is set to no intervention (150_3_0.5_0%_FSyl-80).*

# Plot-Level Indicators Calculation and Visualization

Over the 80-year simulation period, we calculate the following indicators:

- **Hill diversity indices** (richness, Shannon, Simpson, Hill 0, Hill 1, Hill 2)
- **Harvested volume** by scenario
- **Standing biomass** total and by species

- [ ] Work is needed to analyse structural diversity (either find a better forCEEPS output file or analyse the complete output file)

```{r}
productivity_scene <- productivity_scene %>%
  filter(date <= "2100")

mean_scene <- mean_scene %>%
  filter(date <= "2100")
```

```{r}
# 1. Calculate Hill diversity indices
div <- productivity_scene %>%
  filter(adultTreeNumber_ha > 0) %>%
  group_by(plot_id, date, scenario) %>%
  mutate(
    abundance = adultTreeNumber_ha / sum(adultTreeNumber_ha, na.rm = TRUE)
  ) %>%
  summarise(
    richness = n_distinct(speciesShortName),
    shannon = -sum(abundance * log2(abundance), na.rm = TRUE),
    simpson = sum((abundance^2), na.rm = TRUE),
    hill_0 = richness,
    hill_1 = exp(shannon),
    hill_2 = 1 / simpson,
    .groups = "drop"
  )

# 2. Calculate extracted volume by scenario
mean_scene1 <- mean_scene %>%
  group_by(plot_id, date, scenario) %>%
  summarise(
    extracted_volume_m3_ha =
      max(totalVolume.m3.ha, na.rm = TRUE) - min(totalVolume.m3.ha, na.rm = TRUE),
    .groups = "drop"
  )

# 3. Biomass by species
biomasse_par_espece <- productivity_scene %>%
  mutate(type = "By species")

# 4. Total biomass by plot
biomasse_totale <- productivity_scene %>%
  group_by(plot_id, date, scenario) %>%
  summarise(
    adultTreeBasalArea = sum(adultTreeBasalArea, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(speciesShortName = "Total", type = "Total")

# 5. Combine biomass data
biomasse_all <- bind_rows(
  biomasse_par_espece %>% mutate(type = "By species"),
  biomasse_totale
)

# 6. Final merge: diversity + volume + biomass
final_table <- biomasse_all %>%
  left_join(div, by = c("plot_id", "date", "scenario")) %>%
  left_join(mean_scene1, by = c("plot_id", "date", "scenario"))
```

```{r}
p_volume <- 
  ggplot(final_table,
         aes(x = date, y = extracted_volume_m3_ha, color = scenario)) +
  facet_wrap(~plot_id) +
  geom_line() +
  labs(
    title = "Harvested Wood Volume by Plot",
    x = "Year",
    y = "Extracted Volume (m³/ha)",
    color = "Scenario"
  ) +
  theme_minimal()

p_ba <- 
  ggplot(final_table,
         aes(x = date, y = adultTreeBasalArea,
             color = speciesShortName, linetype = type)) +
  geom_line() +
  facet_grid(plot_id ~ scenario) +
  labs(
    title = "Standing Biomass by Plot, Species, and Total",
    x = "Year",
    y = "Standing Biomass (m²/ha)",
    color = "Species",
    linetype = "Type"
  ) +
  theme_minimal()

# Different color for each Hill indicator (0, 1, 2)
p_diversity <- ggplot(final_table, aes(x = date)) +
  geom_line(aes(y = hill_0), color = "blue") +
  geom_line(aes(y = hill_1), color = "green") +
  geom_line(aes(y = hill_2), color = "red") +
  facet_grid(plot_id ~ scenario) +
  labs(
    title = "Diversity Indices (Hill 0: Blue, Hill 1: Green, Hill 2: Red)",
    x = "Year",
    y = "Diversity Index"
  ) +
  theme_minimal()
```

```{r, fig.height=20}
p_volume + p_ba + p_diversity +
  plot_layout(ncol = 1)
```

# Global Indicators

To create scenarios I combined different itineraries together.  

To be able to conclude on different proportions effect and to take into account that the dynamic of one scenario can depend on which plot were chosen I repeated each scenarios 10 time. Exemple : for half clearcut, half no management, I randomly selected half of the plots for each itinerary and repeated this process 10 times to capture variability in the results.

```{r}
generate_scenario <- function(mean_scene,
                              productivity_scene,
                              itineraries, proportions,
                              name,
                              itineraries_map,
                              n_reps = 10,
                              seed = 123) {
  set.seed(seed)

  all_mean <- list()
  all_prod <- list()

  for (rep_i in seq_len(n_reps)) {
    # Get all distinct plots
    all_plots <- unique(mean_scene$plot_id)

    # Shuffle plots to randomize
    shuffled_plots <- sample(all_plots)

    # Calculate number of plots per itinerary according to proportions
    n_plots <- length(all_plots)
    n_per_itin <- round(proportions * n_plots)

    # Adjust if sum is not exactly equal (due to rounding)
    diff_plots <- n_plots - sum(n_per_itin)
    if (diff_plots != 0) {
      n_per_itin[1] <- n_per_itin[1] + diff_plots
    }

    # Assign plots to each itinerary
    idx_start <- 1
    selected_plots_list <- list()
    for (i in seq_along(itineraries)) {
      idx_end <- idx_start + n_per_itin[i] - 1
      selected_plots_list[[i]] <- shuffled_plots[idx_start:idx_end]
      idx_start <- idx_end + 1
    }

    # Extract and rename data
    mean_scene_mix <-
      purrr::map2_dfr(
        itineraries, selected_plots_list,
        function(itin, plots) {
          mean_scene %>%
            filter(plot_id %in% plots, scenario == itineraries_map[[itin]])
        }
      ) %>%
      mutate(scenario = name, rep = rep_i)

    productivity_scene_mix <-
      purrr::map2_dfr(
        itineraries, selected_plots_list, function(itin, plots) {
          productivity_scene %>%
            filter(plot_id %in% plots, scenario == itineraries_map[[itin]])
        }
      ) %>%
      mutate(scenario = name, rep = rep_i)

    all_mean[[rep_i]] <- mean_scene_mix
    all_prod[[rep_i]] <- productivity_scene_mix
  }

  list(
    mean_scene = bind_rows(all_mean),
    productivity_scene = bind_rows(all_prod)
  )
}
```

```{r}
compute_mean_indicators <- function(mean_scene) {
  mean_scene %>%
    group_by(scenario, date, plot_id, rep) %>%
    summarise(
      volume_extracted_m3_ha = max(totalVolume.m3.ha, na.rm = TRUE) - min(totalVolume.m3.ha, na.rm = TRUE),
      totalBasalAream2_ha = min(totalBasalArea.m2.ha, na.rm = TRUE),
      .groups = "drop_last"
    ) %>%
    group_by(scenario, date, rep) %>%
    summarise(
      extracted_volume_m3_ha = mean(volume_extracted_m3_ha, na.rm = TRUE),
      totalBasalAream2_ha = mean(totalBasalAream2_ha, na.rm = TRUE),
      .groups = "drop_last"
    ) %>%
    group_by(scenario, rep) %>% # grouper par scénario et répétition
    arrange(date, .by_group = TRUE) %>% # trier par date dans chaque groupe
    mutate(cumul_volume = cumsum(extracted_volume_m3_ha)) %>% # cumul dans l'ordre
    ungroup()
}


compute_diversity_indicators <- function(productivity_scene) {
  # Local diversity
  local_div <- productivity_scene %>%
    filter(adultTreeNumber_ha > 0) %>%
    group_by(plot_id, date, scenario, rep) %>%
    mutate(abundance = adultTreeNumber_ha / sum(adultTreeNumber_ha, na.rm = TRUE)) %>%
    summarise(
      richness = n_distinct(speciesShortName),
      shannon = -sum(abundance * log2(abundance), na.rm = TRUE),
      simpson = sum((abundance^2), na.rm = TRUE),
      hill_0 = richness,
      hill_1 = exp(shannon),
      hill_2 = 1 / simpson,
      .groups = "drop"
    ) %>%
    group_by(scenario, date, rep) %>%
    summarise(
      hill_0_local = mean(hill_0, na.rm = TRUE),
      hill_1_local = mean(hill_1, na.rm = TRUE),
      hill_2_local = mean(hill_2, na.rm = TRUE),
      .groups = "drop"
    )

  # Global diversity
  global_div <- productivity_scene %>%
    filter(adultTreeNumber_ha > 0) %>%
    group_by(scenario, date, rep, speciesShortName) %>%
    summarise(abundance = sum(adultTreeNumber_ha, na.rm = TRUE), .groups = "drop") %>%
    group_by(scenario, date, rep) %>%
    mutate(rel_abundance = abundance / sum(abundance, na.rm = TRUE)) %>%
    summarise(
      richness = n_distinct(speciesShortName),
      shannon = -sum(rel_abundance * log2(rel_abundance), na.rm = TRUE),
      simpson = sum(rel_abundance^2, na.rm = TRUE),
      hill_0_global = richness,
      hill_1_global = exp(shannon),
      hill_2_global = 1 / simpson,
      .groups = "drop"
    )

  # Merge both
  full_div <- local_div %>%
    left_join(global_div, by = c("scenario", "date", "rep"))

  return(full_div)
}
```

```{r}
# Define homogeneous and mixed scenarios
scenario_mix_list <- list(
  clear_cut        = list(itin = c("clear_cut"), props = c(1)),
  continuous_cover = list(itin = c("continuous_cover"), props = c(1)),
  natural_evolution = list(itin = c("natural_evolution"), props = c(1)),
  mix_clear_cont   = list(itin = c("clear_cut", "continuous_cover"), props = c(0.5, 0.5)),
  mix_clear_nat    = list(itin = c("clear_cut", "natural_evolution"), props = c(0.5, 0.5)),
  mix_cont_nat     = list(itin = c("continuous_cover", "natural_evolution"), props = c(0.5, 0.5)),
  mix_all          = list(itin = c("clear_cut", "continuous_cover", "natural_evolution"), props = c(0.4, 0.3, 0.3))
)

# Name mapping
itineraries_map <- list(
  clear_cut         = "simulation_1",
  continuous_cover  = "simulation_2", 
  natural_evolution = "simulation_3"
)
```

```{r}
all_mean_scene <- list()
all_prod_scene <- list()

for (scenario_name in names(scenario_mix_list)) {
  config <- scenario_mix_list[[scenario_name]]

  if (length(config$itin) == 1) {
    # Homogeneous scenarios: single draw (no need to repeat)
    generated <- generate_scenario(
      mean_scene = mean_scene,
      productivity_scene = productivity_scene,
      itineraries = config$itin,
      proportions = config$props,
      name = scenario_name,
      itineraries_map = itineraries_map,
      n_reps = 1, # no repetition for homogeneous scenarios
      seed = 123
    )
    # No rep column, add rep = 1 for consistency
    generated$mean_scene$rep <- 1
    generated$productivity_scene$rep <- 1
  } else {
    # Mixed scenarios: repetitions for variability
    generated <- generate_scenario(
      mean_scene = mean_scene,
      productivity_scene = productivity_scene,
      itineraries = config$itin,
      proportions = config$props,
      name = scenario_name,
      itineraries_map = itineraries_map,
      n_reps = 10, # desired number of repetitions
      seed = 123
    )
  }

  all_mean_scene[[scenario_name]] <- generated$mean_scene
  all_prod_scene[[scenario_name]] <- generated$productivity_scene
}

# Merge all results
combined_mean <- bind_rows(all_mean_scene)
combined_prod <- bind_rows(all_prod_scene)

# Add group_by(rep) in indicator calculation functions
df_mean <- compute_mean_indicators(combined_mean) %>%
  group_by(scenario, date, rep) %>%
  summarise_all(first) %>% # or other appropriate aggregation
  ungroup()

df_div <- compute_diversity_indicators(combined_prod) %>%
  group_by(scenario, date, rep) %>%
  summarise_all(first) %>%
  ungroup()

final_df <- left_join(df_mean, df_div, by = c("scenario", "date", "rep"))
```


```{r}
p_vol <- ggplot(final_df, aes(x = date, y = cumul_volume, color = scenario)) +
  geom_line() +
  labs(
    title = "Cumulative Harvested Volume by Scenario",
    x = "Year", y = "Volume (m³/ha)"
  ) +
  theme_minimal()

p_div_global <- ggplot(final_df, aes(x = date, y = hill_1_global, color = scenario)) +
  geom_line() +
  labs(
    title = "Global Shannon Diversity (Hill 1)",
    x = "Year", y = "Hill 1"
  ) +
  theme_minimal()

p_div_local <- ggplot(final_df, aes(x = date, y = hill_1_local, color = scenario)) +
  geom_line() +
  labs(
    title = "Local Shannon Diversity (Hill 1)",
    x = "Year", y = "Hill 1"
  ) +
  theme_minimal()

p_ba <- ggplot(final_df, aes(x = date, y = totalBasalAream2_ha, color = scenario)) +
  geom_line() +
  labs(
    title = "Basal Area",
    x = "Year", y = "Basal Area (m²/ha)"
  ) +
  theme_minimal()
```

```{r}
(p_vol + p_ba) / (p_div_global + p_div_local) +
  plot_layout(ncol = 1) +
  plot_annotation(title = "Global Indicators by Scenario and Replication")
```


```{r}
p_div_global <- ggplot(final_df %>% filter(scenario == "clear_cut"), aes(x = date, y = hill_1_global, color = scenario)) +
  geom_line() +
  labs(
    title = "Global Shannon Diversity (Hill 1)",
    x = "Year", y = "Hill 1"
  ) +
  theme_minimal()

p_div_local <- ggplot(final_df %>% filter(scenario == "clear_cut"), aes(x = date, y = hill_1_local, color = scenario)) +
  geom_line() +
  labs(
    title = "Local Shannon Diversity (Hill 1)",
    x = "Year", y = "Hill 1"
  ) +
  theme_minimal()

p_div_local + p_div_global +
  plot_layout(ncol = 1) +
  plot_annotation(title = "Shannon Diversity (Hill 1) for Clear-cut Management")
```


# Relationships Between Global Indicators

```{r}
aggregated <- final_df %>%
  group_by(scenario, rep) %>%
  summarise(
    cumul_volume = max(cumul_volume, na.rm = TRUE),
    mean_totalBasalAream2_ha = mean(totalBasalAream2_ha, na.rm = TRUE),
    mean_hill_1_global = mean(hill_1_global, na.rm = TRUE),
    mean_hill_1_local = mean(hill_1_local, na.rm = TRUE),
  )
```

```{r}
p_div_local_global <- ggplot(aggregated, aes(x = mean_hill_1_global, y = mean_hill_1_local, color = scenario)) +
  geom_point() +
  # The line y = x
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "grey") +
  labs(
    title = "Relationship Between Global and Local Diversity",
    x = "Hill 1 Global", y = "Hill 1 Local"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

p_div_vol <- ggplot(aggregated, aes(x = cumul_volume, y = mean_hill_1_global, color = scenario)) +
  geom_point() +
  labs(
    title = "Relationship Between Harvested Volume and Global Diversity",
    x = "Cumulative Volume (m³/ha)", y = "Hill 1 Global"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

p_vol_ba <- ggplot(aggregated, aes(x = cumul_volume, y = mean_totalBasalAream2_ha, color = scenario)) +
  geom_point() +
  labs(
    title = "Relationship Between Harvested Volume and Basal Area",
    x = "Cumulative Volume (m³/ha)", y = "Basal Area (m²/ha)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

p_div_ba <- ggplot(aggregated, aes(x = mean_hill_1_global, y = mean_totalBasalAream2_ha, color = scenario)) +
  geom_point() +
  labs(
    title = "Relationship Between Global Diversity and Basal Area",
    x = "Hill 1 Global", y = "Basal Area (m²/ha)"
  ) +
  theme_minimal()
```

```{r}
p_div_local_global + p_div_vol + p_vol_ba + p_div_ba +
  plot_layout(ncol = 2) +
  plot_annotation(title = "Relationships Between Global Indicators")
```


```{r}
# 3D plot
library(plotly)
plot_ly(aggregated, x = ~cumul_volume, y = ~mean_hill_1_global, z = ~mean_totalBasalAream2_ha, color = ~scenario, type = "scatter3d", mode = "markers") %>%
  layout(
    title = "3D Visualization of Management Scenarios",
    scene = list(
      xaxis = list(title = "Volume (m³/ha)"),
      yaxis = list(title = "Mean Hill 1"),
      zaxis = list(title = "Mean Basal Area (m²/ha)")
    )
  )
```

# Future Work

- [ ] **Select more diverse and representative plots** to better capture forest heterogeneity
- [ ] **Add additional indicators** (structure, canopy cover, recruitment, dead biomass)  
- [ ] **Implement calculations with complete dataset** (code to be written and memory-optimized) as this may be necessary for structural diversity indices (needs consideration, but potentially no other output will contain the necessary data)
- [ ] **Integrate FORCEEPS replications** to calculate means and assess how this fits into the workflow